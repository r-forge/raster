\documentclass{article}

\usepackage{natbib}
\usepackage{graphics}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{hanging}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}

%\VignetteIndexEntry{Introduction to the raster package}

\newcommand{\R}{{\normalfont\textsf{R }}{}}

\SweaveOpts{keep.source=TRUE}

\begin{document}

<<foo,include=FALSE,echo=FALSE>>=
options(keep.source = TRUE, width = 60)
foo <- packageDescription("raster")
@

\title{Introduction to the 'raster' package (Version \Sexpr{foo$Version})}
\author{Robert J. Hijmans}
\maketitle


\section{Introduction}

This vignette describes the \R package '\verb@raster@'. A raster is a spatial (geographic) data structure that divides a region into rectangles ('raster cells') and stores one or more values for each of these rectangles.  Such a data structure is also referred to as a 'grid' and is often contrasted with 'vector' data that is used to represent points, lines, and polygons. 

The \verb@raster@ package has functions for creating, reading, manipulating, and writing raster data. The package provides, among other things, general low-level raster data manipulation functions to, for example, to read a row of raster values from a file or to convert cell numbers to coordinates and back, that can easily be used to develop high-level functions. It also includes a raster algebra implementation  and several high level' functions for raster data manipulation that are common in Geographic Information Systems (GIS) programs. The types of functions in the raster package are similar to those in GIS programs such as Idrisi, the raster functions of GRASS, and the 'grid' module of ArcInfo ('workstation').

A notable feature of the \verb@raster@ package is that it can work with raster datasets that are stored on disk and are too large to be loaded into memory. The package can work with large files because it creates objects from these files that only contain information about the structure of the data, such as the number of rows and columns, the spatial extent, and the filename, but it does not read in all the cell values. In computations with these objects, data is read and processes in chunks. If no output filename specified, and the output raster is too large to keep in memory, the results are written to a temporary file. 

To understand what is covered in this vignette, you must understand the basics of the \R language. There is a multitude of on-line and other resources that can help you to get acqainted with \R. The \verb@raster@ package does not operate in isolation. For example, it depends on the \verb@sp@ package and uses the classes defined in that package for vector type data. See the vignette and help pages of that package or Bivand {\it et al} (2008). Bivand {\it et al} provide an introduction to handling spatial data in \R, and to statistically oriented spatial data analysis (such as inference from spatial data, point pattern analysis, and geostatistics) and some of the \R packages that can be used for that (it does not mention the 'raster' package as the book came out before it was developed. 

In the next section, I discuss some general aspects of the design of the package, notably the structure of the main classes, and what they represent. The use of the package is illustrated in subsequent sections. \verb@raster@ has a large number of functions, not all of them are discussed here, and those that are discussed are mentioned only briefly. See the help files of the package for more information on individual functions and {\bf help("raster-package")} for an index of functions by topic.


\section{Classes}

The package is built around a number of 'S4' classes of which the RasterLayer, \verb@RasterBrick@ , and \verb@RasterStack@ classes are the most important. Classes are used to define data structures, and to match these structures to the appropriate versions of methods (functions). Classes are used by creating (instantiating) objects of that class.  See Chambers (2009) for a detailed discussion of the use of S4 classes in \R. When discussing methods that can operate on all three of these objects, they are referred to as 'Raster*' objects.

\subsection{RasterLayer}

A \verb@RasterLayer@ object represents a single-variable raster dataset. A \verb@RasterLayer@ object always stores a number of fundamental parameters such as the number of columns and rows, the coordinates of its spatial extent (the 'bounding box'), and the coordinate reference system (the 'map projection', although this can be \verb@NA@ ). In addition, a \verb@RasterLayer@ can store information about the file in which the raster cell values are stored (if there is such a file). A \verb@RasterLayer@ can also hold the raster cell values themselves.

\subsection{RasterStack and RasterBrick}

It is quite common to analyze raster data using single-variable objects. However, in many cases multi-variable raster data sets are more useful. The \verb@raster@ package has two classes for multi-raster data the \verb@RasterStack@ and the \verb@RasterBrick@. The principal difference between these two classes is that a \verb@RasterBrick@ can only be linked to a single (multi-layer) file, but in contrast to a \verb@RasterStack@ not to separate files, or to a few layers from a single file. 

A \verb@RasterStack@ is a collection of \verb@RasterLayer@ objects with the same spatial extent and resolution. In essence it is a list of \verb@RasterLayer@ objects. A \verb@RasterStack@ can easily be formed form a collection of files in different locations and these can be mixed with \verb@RasterLayer@ objects that only exist in memory.

A \verb@RasterBrick@  is truly a multilayered object , and processing a \verb@RasterBrick@  can be more efficient than processing a \verb@RasterStack@ representing the same data. However, it can only refer to a single file. A typical example of such a file would be a multi-band satellite image or the output of a global climate model (with e.g.  temperature values for each day of the year for each raster cell).
Methods that operate on \verb@RasterStack@ and \verb@RasterBrick@  objects typically return a \verb@RasterBrick@.


\subsection{Other classes}

Below is some more detail, you do not need to read or understand this section to use the \verb@raster@ package. 

The three classes described above inherit from the \verb@Raster@ class (that means they are derived from this more basic 'parent' class by adding something to that class) which itself inherits from the \verb@BasicRaster@ class. The \verb@BasicRaster@ only has a few properties (referred to as 'slots' in S4 speak): the number of columns and rows, the coordinate reference system (which itself is an object of class \verb@CRS@, which is defined in package '\verb@sp@') and the spatial extent, which is an object of class \verb@Extent@.  

An object of class \verb@Extent@ has four slots: xmin, xmax, ymin, and ymax. These represent the minimum and maximum x and y coordinates of the of the Raster object. These would be, for example,  -180, 180, -90, and 90, for a global raster with longitude/latitude coordinates.  Note that some file systems (and perhaps some software as well) use the coordinates of the center of extreme cells, rather than the extremes of the entire raster. 

\verb@Raster@  is a virtual class. This means that it cannot be instantiated (you cannot create objects from this class). It was created to allow the definition of methods for that class. These methods will be dispatched when called with a descendent of the class (i.e. when the method is called with a \verb@RasterLayer@, \verb@RasterBrick@  or \verb@RasterStack@ object as argument). This allows for efficient code writing because many methods are the same for any of these three classes, and hence a single method for \verb@Raster@ suffices. 

\verb@RasterStackBrick@ is a class union of the \verb@RasterStack@ and \verb@RasterBrick@ class. This is a also a virtual class. It allows defining methods that apply to both a \verb@RasterStack@ and to a \verb@RasterBrick@. Like with the \verb@Raster@ class its purpose is efficiency in code and documentation. 


\section{Creating Raster* objects}

A \verb@RasterLayer@ can easily be created from scratch using the function {\bf raster}. The default settings will create a global raster data structure with a longitude/latitude coordinate reference system and 1 by 1 degree cells. You can change these settings by providing additional arguments such as {\it nrow}, {\it ncol}, to the function. You can also change these parameters after creating the object. In some cases, for example when you change the number of columns or rows, you will loose the values associated with the \verb@RasterLayer@ (or the link to a file if there was one). If you set the projection, this is only to properly define it, not to change it. To tranform a \verb@RasterLayer@ to another coordinate reference system (projection) you can can use the function {\bf projectRaster}. 

Here is an example of creating and changing a \verb@RasterLayer@ object 'r' from scratch.
<<raster-1>>=
library(raster)
# \RasterLayer with the default parameters
r <- raster()
r

# With other parameters
r <- raster(ncol=36, nrow=18, xmn=-1000, xmx=1000, ymn=-100, ymx=900)
# that can be changed
res(r)
res(r) <- 100
res(r)
ncol(r)
ncol(r) <- 18
ncol(r)
res(r)
projection(r) <- "+proj=utm +zone=48 +datum=WGS84"
r
@

Objects 'r' created in the example above only consist of a 'skeleton', that is, we have defined the number of rows and columns, and where the raster is located in geographic space, but there are no cell-values associated with it. Below I illustrate how values can be set, and how they can be accessed again.

<<raster-1a, fig=TRUE , echo=TRUE>>=
r <- raster(ncol=10, nrow=10)
ncell(r)
hasValues(r)
# use the 'values' function
values(r) <- runif(ncell(r))
hasValues(r)
inMemory(r)
values(r)[1:10]

plot(r, main='Raster with 100 cells')
@


The function {\bf raster } also allows you to create a \verb@RasterLayer@ from another object, including another \verb@RasterLayer@, \verb@RasterStack@ and \verb@RasterBrick@ , as well as from a SpatialPixels* and SpatialGrid* object (defined in the \verb@sp@ package), an \verb@Extent@ object, and from a matrix.

It is more common, however, to create \verb@RasterLayer@ objects from files. The raster package can read raster files in several formats, including some 'natively' supported formats and other formats via the \verb@rgdal@ package. Supported formats for reading include ESRI, ENVI, and ERDAS grids and geoTiff.  Most formats supported for reading can also be written too. Here is an example using the 'Meuse' dataset (taken from the \verb@sp@ package), using a file in the native 'rasterfile' format:

<<raster-2a, fig=TRUE , echo=TRUE>>=
r <- raster(system.file("external/test.grd", package="raster"))
filename(r)
hasValues(r)
inMemory(r)
plot(r)
@

Multi-layer objects can be created in memory (from \verb@RasterLayer@ objects) or from files. 

<<raster-2b>>=
# create three identical RasterLayer objects
r1 <- r2 <- r3 <- raster(nrow=10, ncol=10)
# Assign random cell values 
values(r1) <- runif(ncell(r1))
values(r2) <- runif(ncell(r2))
values(r3) <- runif(ncell(r3))

# combine three RasterLayer objects into a RasterStack
s <- stack(r1, r2, r3)
s
nlayers(s)

# combine three RasterLayer objects into a RasterBrick 
b1 <- brick(r1, r2, r3)
# equivalent to:
b2 <- brick(s)

# create a RasterBrick  from file
b <- brick(system.file("external/rlogo.grd", package="raster"))
b
nlayers(b)

# extract a single RasterLayer
r <- raster(b, layer=2)
# equivalent to creating it from disk
r <- raster(system.file("external/rlogo.grd", package="raster"), band=2)
@


\section{Raster algebra}

Many generic functions that allow for simple and elegant raster algebra have been implemented for \verb@Raster*@ objects, including the normal algebraic operators such as {\bf +, -, *, /}, logical operators such as {\bf >, >=, <, ==, !} and functions such as {\bf abs, round, ceiling, floor, trunc, sqrt, log, log10, exp, cos, sin, max, min, range, prod, sum, any, all}. In these functions you can mix \verb@Raster*@ objects with numbers, as long as the first argument is a \verb@Raster*@ object. 

<<raster-3a>>=
r <- raster(ncol=10, nrow=10)
r[] <- 1:ncell(r)
s <- r + 10
s <- sqrt(s)
s <- s * r + 5
r[] <- runif(ncell(r))
r <- round(r)
r <- r == 1
s[r] <- -0.5
s[!r] <- 5
s[s == 5] <- 15
@

If you use multiple \verb@Raster*@ objects (in functions where this is relevant, such as range), these must have the same resolution and origin. The origin of a \verb@Raster*@ object is the point closest to (0, 0) that you could get if you moved from a corners of a \verb@Raster*@ object towards that point in steps of the \verb@x@ and \verb@y@ resolution. Normally these objects would also have the same extent, but if they do not, the returned object covers the spatial intersection of the input objects.

When you use multiple multi-layer objects these must all have the same number or layers, but you can also mix in \verb@RasterLayer@ objects, in which case the \verb@RasterLayer@ object is 'recycled'.

Summary functions {\bf (min, max, mean, prod, sum, Median, cv, range, any, all)} always return a \verb@RasterLayer@ object. Perhaps this is not obvious when using functions like {\bf min, sum or mean}. Use {\bf cellStats} if instead of a \verb@RasterLayer@ you want a single number summarizing the cell values of each layer. 

<<raster-3b>>=
a <- mean(r,s,10)
b <- sum(r,s)
st <- stack(r, s, a, b)
sst <- sum(st)
sst
cellStats(st, 'sum')
cellStats(sst, 'sum')
@



\section{'High-level' functions}

Several 'high level' functions have been implemented for \verb@RasterLayer@ objects. With 'high level' functions we refer to those functions that you would normally find in a GIS program that supports raster data (such as IDRISI, GRASS, or the GRID module in ArcInfo workstation). All these functions work for raster datasets that cannot be loaded into memory. Here we briefly discuss some of these functions. See the help files for more detailed descriptions of each function.

The high-level functions have some arguments in common. The first argument is typically 'x' or 'object' and can be a \verb@RasterLayer@, and in some cases a \verb@RasterStack@ or \verb@RasterBrick@ . It is followed by one or more arguments specific to the function (either additional \verb@RasterLayer@ objects or parameters), followed by a filename="" and ... arguments. The default filename is an empty character "". If you do not specify a filename, the default action for the function is to return a \verb@RasterLayer@ that only exists in memory. However, if the function will create a \verb@RasterLayer@ that is too large to hold memory it is written  to a temporary file instead. The ...  argument allows for setting additional arguments that are relevant when writing values to a file: the file format, datatype, and a logical value indicating whether existing files should be overwritten. 

\subsection{Structural modification}
There are several functions that deal with modifying the structure of \verb@RasterLayer@ objects. {\bf aggregate} and {\bf disaggregate} allow for changing the resolution of a RasterLayer. In the case of {\bf aggregate}, you need to specify a function determining what to do with the grouped cell values (e.g. {\bf mean}). It is possible to specify different (dis) aggregation factors in the x and y direction. {\bf aggregate} and {\bf disaggregate} are the best functions when adjusting cells size only, and with an integer fraction (e.g. each side 2 times smaller or larger), but in some cases that is not possible. For example, you may need nearly the same cell size, while shifting the cell centers. In those cases, the {\bf resample} function might be used. It can do either nearest neighbor assignments (for categorical data) or bilinear interpolation (for non-categorical data). Simple linear shifts of a Raster object can be accomplished with the {\bf shift} function or with the {\bf extent} function.
 
The {\bf crop} function lets you take a geographic subset of a larger RasterLayer. You can crop a \verb@RasterLayer@ by providing an extent object or another spatial object from which an extent can be extracted (objects from classes deriving from Raster and from Spatial in the sp package). An easy way to get an extent object is to plot the larger \verb@RasterLayer@ and then use {\bf drawExtent()} to visually determine the new extent (bounding box) to provide to the crop function. 

{\bf trim} crops a \verb@RasterLayer@ by removing the outer rows and columns that only contain NA values. In contrast, {\bf expand} adds new rows and/or columns with NA values. The purpose of this could be to create a new \verb@RasterLayer@ of the same extent of another larger \verb@RasterLayer@ such that the can be used in raster algebra. 

The {\bf merge} function lets you merge 2 or more \verb@RasterLayer@ objects into a single new object. The input objects must have the same resolution and origin (that is their cells neatly fit in a single larger RasterLayer). 

With the {\bf projectRaster} function you can transform values of \verb@RasterLayer@ to a new coordinate reference system.

<<raster-5>>=
r <- raster()
r[] <- 1:ncell(r)
ra <- aggregate(r, 10)
r1 <- crop(r, extent(-180,0,0,30))
r2 <- crop(r, extent(-10,180,-20,10))
m <- merge(r1, r2, filename='test.grd', overwrite=TRUE)
@

{\bf flip} lets you flip the data (reverse order) in horizontal or vertical direction -- typically to correct for a 'communication problem' between different R packages or a misinterpreted file. {\bf rotate} lets you rotate longitude/latitude rasters that have longitudes from 0 to 360 degrees to the standard -180 to 180 degrees system. 


\subsection{Overlay}
As an alternative to the raster algebra discussed above, the following 'high-level' functions are available to accomplish the same things: {\bf overlay}, {\bf calc}, {\bf reclass}, {\bf subs}, {\bf cover} and {\bf mask}. These provide either easy to use short-hand, or more efficient computation (for disk based RasterLayers). {\bf calc} allows you to do a computation for a single \verb@RasterLayer@ whereas with {\bf overlay} you can combine multiple layers. Use {\bf reclass} to replace ranges of values with single values, or {\bf subs} to substitute (replace) single values with other values. Function {\bf mask} removes all values from one layer that are NA in another layer, and {\bf cover} combines two layers by taking the values of the first layer except where these are NA.

<<raster-6>>=
r <- raster(ncol=10, nrow=10)
r[] <- round(runif(ncell(r))*10)
s <- calc(r, function(x){ x[x < 2] <- NA; return(x)} )
t <- overlay(r, s, fun=function(x, y){ x / (2 * sqrt(y)) + 5 } )
u <- mask(r, t)
v = u==s
w <- cover(t, r)
x <- reclass(w, c(0,1,1,  1,5,2, 4,10,3))
y <- subs(w, data.frame(id=c(0,2), v=c(40,50)))
@


\subsection{Focal functions}
There are three focal (neighorhood) functions: {\bf focal}, {\bf focalFilter}, {\bf focalNA}. These functions make a computation using values in a neighborhood of cells around a focal cell, and putting the result in the focal cell of the output RasterLayer. With {\bf focal}, the neighborhood can only be a rectangle. With {\bf focalFilter}, the neighborhood is a user-defined a matrix of weights and could approximate any shape by giving some cells zero weight. The {\bf focalNA} function only computes new values for cells that are NA in the input RasterLayer.


\subsection{Distance}
There are a number of distance related functions. {\bf distance} computes the shortest distance to cells that are not NA. {\bf pointDistance} computes the shortest distance to any point in a set of points. {\bf gridDistance} computes the distance when following grid cells that can be traversed (e.g. exluding water bodies). {\bf direction} computes the direction towards (or from) the nearest cell that is not NA. {\bf adjacency} determines which cells are adjacent to other cells, and {\bf pointDistance} computes distance between points. See the gdistance package for more adanced distance calculations (cost distance, resistance distance)

\subsection{Spatial configuration}
Function {\bf clump} identifies groups of cells that are connected. {\bf edge} identifies edges, that is transitions beween cell values. {\bf area} computes the size of each grid cell (for unprojected rasters)

\subsection{Predictions}
The package has two functions to make model predictions to (potentially very large) rasters. {\bf predict} takes a multilayer raster and a fitted model as arguments. Fitted models can be of various classes, including glm, gam, randomforest, and brt. Function {\bf interpolate} is similar but is for models that use coordinates as predictor variables, for example in kriging and spline interpolation.


\subsection{Vector to raster conversion}
The raster packages supports point, line, and polygon to raster conversion. For vector type data (points, lines, polygons), objects of classes defined in the \verb@sp@ package are used; but points can also be represented by a two-column matrix (x and y). 

Point to raster conversion is often done with the purpose to analyze the point data. For example to count the number of distinct species (represented by point observations) that occur in each raster cell. {\bf pointsToRaster} takes a \verb@RasterLayer@ to set the spatial extent and resolution, and a function to determine how to summarize the points (or an attribute of each point) by cell. 

Polygon to raster conversion (with {\bf polygonsToRaster}) is typically done to create a RaterLayer that can act as a mask, i.e. to set to NA a set of cells of a \verb@RasterLayer@, or to summarize values on a raster by zone. For example a country polygon is transferred to a raster that is then used to set all the cells outside that country to NA; whereas polygons representing administrative regions such as states can be transferred to a raster to summarize raster values by state. 

It is also possible to convert the valus of a \verb@RasterLayer@ to points or polygons, using {\bf rasterToPoints} and {\bf rasterToPolygons}. Both functions only return values for cells that are not NA. Unlike {\bf rasterToPolygons}, {\bf rasterToPoints} is reasonably efficient and allows you to provide a function to subset the output before it is produced (which can be necessary for very large rasters as the point object is created in memory). 



\section{Summary functions}

When used with a \verb@RasterLayer@ as first argument, normal summary statistics functions such as min, max and mean return a RasterLayer. To, instead, obtain a summary for all cells of a single \verb@RasterLayer@ you can use cellStats. You can use {\bf freq} to make a frequency table, or {\bf count} to count the number of cells with a specified value. Use {\bf zonal} to summarize a \verb@RasterLayer@ using zones (areas with the same integer number) defined in another \verb@RasterLayer@ and {\bf crosstab} to cross-tabulate two \verb@RasterLayer@ objects.

<<raster-7>>=
r <- raster(ncol=36, nrow=18)
r[] <- runif(ncell(r))
cellStats(r, mean)
s = r
s[] <- round(runif(ncell(r)) * 5)
zonal(r,s,median)
freq(s)
count(s, 3)
crosstab(r*3, s)
@


\section{Plotting}
Several generic functions have been implemented for Raster* objects to create maps and other plot types. Use 'plot' to create a map of a RasterLayer.
When plot is used with a \verb@RasterLayer@, it uses code taken from the image.plot function in the fields package, which calls the function 'image' (but, by default, adds a legend). It is also possible to directly call {\bf image}. You can zoom in using 'zoom' and clicking on the map twice (to indicate where to zoom to). After plotting a \verb@RasterLayer@ you can add vector type spatial data (points, lines, polygons). You can do this with functions points, lines, polygons if you are using the basic R data structures or plot(object, add=TRUE) if you are using Spatial* objects as defined in the sp package. When plot is used with a multi-layer Raster* object, all layers are plotted (up to 16), unless the layers desired are indicated with an additional argument.

Multi-layer Raster objects can be plotted as individual layers
<<raster-2c, fig=TRUE , echo=TRUE>>=
plot(b)
@

They can also be combined into a single image, by assigning indiviudal layers to one of the three color channels (red, green and blue):
<<raster-2d, fig=TRUE , echo=TRUE>>=
plotRGB(b, r=1, g=2, b=3)
@


You can also use the following functions with a \verb@RasterLayer@ as argument: {\bf hist, persp, contour}, and {\bf density}. See the help files for more info. You can use {\bf plot3D} to create an interactive 3D plot (you need the rgl package for this).

With {\bf click} it is possible to interactively query a Raster* object by clicking once or several times on a map plot.


\section{Writing files}

\subsection{File format}

Raster can read most, and write several raster file formats, via the \verb@rgdal@ package. However, it directly reads and writes a native 'rasterfile' format. A rasterfile consists of two files: a binary sequential data file and a text header file. The header file is of the "windows .ini" type. When reading, you do not have to specify the file format, but you do need to do that when writing (except when using the default native format). This file format is also used in DIVA-GIS (\url{http://www.diva-gis.org/}). See the help files for functions {\bf writeRaster} and {\bf saveAs}.



\section{Row, column and cell numbers}

The cell number is an important concept in the raster package. Raster data can be thought of as a matrix, but in a \verb@RasterLayer@ it is more commonly treated as a vector. Cells are numbered from the upper left cell to the upper right cell and then continuing on the left side of the next row, and so on until the last cell at the lower-right side of the raster. There are several helper functions to determine the column or row number from a cell and vice versa, and to determine the cell number for x, y coordinates and vice versa.

<<raster-8>>=
library(raster)
r <- raster(ncol=36, nrow=18)
ncol(r)
nrow(r)
ncell(r)
rowFromCell(r, 100)
colFromCell(r, 100)
cellFromRowCol(r,5,5)
xyFromCell(r, 100)
cellFromXY(r, c(0,0))
colFromX(r, 0)
rowFromY(r, 0)
@


\section{Accessing cell values}

Cell values can be accessed with several methods. Use {\bf getValues} to get all values or a single row; and {\bf getValuesBlock} to read a block (rectangle) of cell values. 

<<raster-10>>=
r <- raster(system.file("external/test.grd", package="raster"))
getValues(r, 50)[35:39]
getValuesBlock(r, 50, 1, 35, 5)
@


You can also read values using cell numbers or coordinates (xy) using the {\bf extract} method.
<<raster-11>>=
cells <- cellFromRowCol(r, 50, 35:39)
cells
extract(r, cells)
xy = xyFromCell(r, cells)
xy
extract(r, xy)
@

In addition, you can use standard R indexing to access values. You can also to replace values (assign new values to cells).  If you replace a value in a \verb@RasterLayer@ based on a file, the connection to that file is lost (because it now is different from that file). Setting raster values for very large files will be very slow with this approach as each time a new (temporary) file, with all the values, is written to disk. 

<<raster-12>>=
r[cells] 
r[1:4]
filename(r)
r[2:3] <- 10
r[1:4]
filename(r)
@

Note that in the above examples values are retrieved using cell numbers. That is, a raster is represented as a (one-dimensional) vector. Values can also be inspected using a (two-dimensional) matrix notation. To do so you need to use double brackets. As in ordinary R matrices, the first index represents the row number, the second the column number.

<<raster-13>>=
r[1]
r[2,2]
r[1,]
r[,1]
r[1:3,1:3]
@

Accessing values through this type of indexing should be avoided inside functions as it is less efficient than accessing values via functions like {\bf getValues}. 




\section{Session options}

There are a number of session options that can be set and these can be saved to make them persistent in between sessions. We would advice against changing the default values unless you have pressing need to do so. They all have to do with reading and writing files. You can set the preferred file format and data type. You can set the default value for overwrite to TRUE (be careful with that one!), and you specify a default progress-bar. All of these values can also be provided as arguments of functions where they apply. Except for generic functions like mean, '+', and sqrt. These functions may write a file when the result is too large to hold in memory and then these options can only be set through the session options. You can also set the tmpdir, the location where such files are written. The option chunksize determines the maximum size (in number of cells) of a single chunk of values that is read/written in chunk-by-chunk processing of very large files. 


\section{Coercion to objects of other classes}

Although the raster package defines its own set of classes, it is easy to coerce objects of these classes to objects of the 'spatial' family defined in the sp package. This allows for using functions defined by sp (e.g. spplot) and for using other packages that expect spatial* objects. To create a Raster object from variable n in a SpatialGrid* x use \verb@raster(x, n)@ or \verb@stack(x)@ or \verb@brick(x)@. Vice versa use \verb@as( , )@

You can also convert objects of class "im" (spatstat) and "asc" (adehabitat) to a \verb@RasterLayer@ and "kasc" (adehabitat) to a \verb@RasterStack@ or Brick using the \verb@raster(x)@, \verb@stack(x)@ or \verb@brick(x)@ function.

<<raster-20>>=
r1 <- raster(ncol=36, nrow=18)
r2 <- r1
r1[] <- runif(ncell(r1))
r2[] <- runif(ncell(r1))
s <- stack(r1, r2)
sgdf <- as(s, 'SpatialGridDataFrame')
newr2 <- raster(sgdf, 2)
news <- stack(sgdf)
@


\section{Extending raster objects}

It is straightforward to build on the Raster* objecs using the S4 inheritance mechanism. Say you need objects that behave like a \verb@RasterLayer@, but have some additional proerties that you need to use in your own functions (S4 methods). See John Chambers' book "Software for Data Analysis, Programming with R" (Springer, 2008), and the help pages of the Methods package for more info. Below is an example:

<<raster-32, fig=TRUE>>=
setClass ('myRaster',
	contains = 'RasterLayer',
	representation (
		important = 'data.frame',
		essential = 'character'
	) ,
	prototype (
		important = data.frame(),
		essential = ''
	)
)
	
r = raster(nrow=10, ncol=10)

m <- as(r, 'myRaster')
m@important <- data.frame(id=1:10, value=runif(10))
m@essential <- 'my own slot'
m[] <- 1:ncell(m)
plot(m)
@

<<raster-33>>=
setMethod ('show' , 'myRaster', 
	function(object) {
		callNextMethod(object) # call show(RasterLayer)
		cat('essential:', object@essential, '\n')
		cat('important information:\n')
		print( object@important)
	})	
	
m
@



\section{References}

\begin{hangparas}{3em}{1}

\noindent Bivand, R.S., E.J. Pebesma and V. Gomez-Rubio, 2008. Applied Spatial Data Analysis with \R. Springer. 378p.

\noindent Chambers, J.M., 2009. Software for Data Analysis: Programming with \R. Springer. 498p.

\end{hangparas}


\end{document}
