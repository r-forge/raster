\documentclass{article}

\usepackage{natbib}
\usepackage{graphics}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}

\DeclareMathOperator{\var}{var}
\DeclareMathOperator{\cov}{cov}

% \VignetteIndexEntry{raster package}

\begin{document}

<<foo,include=FALSE,echo=FALSE>>=
options(keep.source = TRUE, width = 60)
foo <- packageDescription("raster")
@

\title{The "raster" package (Version \Sexpr{foo$Version})}
\author{Robert J. Hijmans}
\maketitle


\section{Introduction}

This is a -very brief- vignette for the \verb@raster@ package in R.  The \verb@raster@ package has functions for with spatial raster (grid) data access and manipulation. The package was developed to (1) to provide general low-level raster data manipulation functions (e.g. read raster values by row) that can easily be used to develop higher level specific functions; (2) assure that all these functions can work with very large raster datasets, that are stored on disk as they cannot be loaded into memory; (3) to provide 'high level' functions for raster data manipulation and management that are also commonly available in GIS software; and (4) to provide an easy-to-use raster algebra implementation. 

High level functions include overlay, merge, aggregate, projection, resample, distance, polygon to raster conversion. All these functions work for raster datasets that cannot be loaded into memory. Reading and writing data for most file formats is done via the \verb@rgdal@ package. For 'vector type data (points, lines, polygons), objects of classes defined in the \verb@sp@ package are used. 

With this package, together with other efforts, we would like to help build a bridge to -the powerful statistics and modeling of- R for the "GIS" community. Our perspective is that standard GIS is too map-centric, and that proper data-analysis needs tools that are more model and data centric. 


\section{Some examples}

The first thing to do is to install \verb@raster@ package if you have not yet done so. As the package is currently not on CRAN, this takes a tiny bit more effort than installing packages that are on CRAN. \verb@raster@ depends on \verb@sp@ and \verb@rgdal@ so if you do not have these packages, intsall them first: 
\verb@install.packages(c("rgdal", "sp")@
Now install \verb@raster@ from the R-Forge repository
\verb@install.packages("raster", repos="http://R-Forge.R-project.org")@

The following R statements should now work
<<raster-1>>=
library(raster)
r <- raster(ncol=36, nrow=18)
r
r <- setValues(r, runif(ncell(r)))
plot(r)
@

The command \verb@r <- raster()@ creates a RasterLayer object. RasterLayer objects consist of several parameters describing a raster dataset, such as the number of columns and rows, and the spatial extent. A RasterLayer object does not necessarily contain any raster cell values. Frequently these values are stored in a file on disk. In this first example we do not have a reference to a file, so we provided some values to the RasterLayer.  

It is probably more common to create a RasterLayer from a file. The raster package can read raster files support by rgdal and grid data in netCDF format. Here is an example using the Meuse dataset that comes with the sp package:

<<raster-2>>=
r <- raster(system.file("external/test.ag", package="sp"))
r
r <- readRow(r, 50)
values(r)
s <- sqrt(r) - 5
plot(s)
@

The command \verb@r <- raster(filename)@ creates a raster object describing the data on file, but not reading the actual raster cell values. \verb@readRow@ reads the values of a specified row of a raster file into memory. \verb@readAll@ reads all values, but this may not be possible if the file is very large. \verb@values(r)@ returns the values that are currently in memory (i.e. those of row 50). \verb@s <- sqrt(r) - r + 1@ is an example of raster algebra. \verb@s@ is a new RasterLayer, its values are the square root of r minus 5. The computation was done for the entire raster, not just for the values that were in memory. The new values are available in memory and can be inspected via \verb@plot@, @values(r)@, or via indexing. 

\section{Indexing}

The values of a RasterLayer are normally repersented as a (one dimensional) vector, starting in the upper left corner and then increasing to the right and then down row by row from left to right untill the last cell in the lower-right corner. Values can be inspected by using the standard x[] notation. You can also this notation to replace values, but only when the whole dataset can be loaded into memory. But note that if you replace a value in a RasterLayer, the connection to the original file is lost.


<<raster-3>>=
r <- raster(system.file("external/test.ag", package="sp"))
r[1]
dataContent(r)
filename(r)
r[1] <- 5
dataContent(r)
filename(r)
@

Values can also be inspected using a two-dimensional notation. To do so you need to use double brackets.

<<raster-4>>=
r[[1,1]]
r[[1:3,1:3]]
r[[75:90, 15]]
@


\section{High level functions}

Several 'high level functions' have been implemented. These are functions that are typically available for raster data manipulation in GIS packages.

<<raster-5>>=
r <- raster()
r[] <- 1:ncell(r)
s <- setValues(r, runif(ncell(r)))
ra <- aggregate(r, 10)
r1 <- crop(r, newExtent(-180,0,0,30))
r2 <- crop(r, newExtent(-10,180,-20,10))
m <- merge(r1, r2)
o1 <- overlay(r, s, fun=function(x,y){return(x*y)})
# this is the same as
o2 <- r * s
d <- disaggregate(m, 2)
@


\section{Large files}

The raster package can work with extremely large files because it does not load the files into memory. When a RasterLayer object is created form a file, the object stores some information about the data on disk (number of rows and columns, spatial extent), and it contains a pointer to that file, to read parts of the data as needed. In computations such as raster algebra or the 'higher level functions', data will normally be read in chunks, processed, and written to disk again. If there is no output filename specified (or if that is not possible such as is the case with raster algebra), the results will be written to a temporary file. If you want to keep that file you should move it another location, e.g. using the copyRasterFile or moveRasterFile functions. At the start of each session, the raster package will attempt to delete temporary files it has created in previous sessions. 


\section{File format}

Raster can read most, and write several raster file formats, via the rgdal package. However, it directly reads and writes a native 'rasterfile' format. A rasterfile consists of two files: a binary sequential data file and a text header file. The header file is of the "windows .ini" type. When reading, you do not have to specify the file format, but you do need to do that when wriring (except when using the default native format). This file format is also used in DIVA-GIS (\url{http://www.diva-gis.org/}).


\section{RasterStack}

A RasterStack is a collection of RasterLayers with the same spatial extent and resolution.


\section{coercion to sp objects}

Although the raster package defines its own set of classes, it is easy to coerce objects of these classes to objects of the 'spatial' family defined by sp. This allows for using functions defined by sp (e.g. spplot) and for using other packages that expect spatial* objects. To create a RasterLayer from variable n in a SpatialGrid* x use \verb@raster(x, n)@ or \verb@stack(x)@. Vice versa use \verb@as( , )@

<<raster-6>>=
r1 <- raster(ncol=36, nrow=18)
r2 <- r1
r1[] <- runif(ncell(r1))
r2[] <- runif(ncell(r1))
s <- stack(r1, r2)
sgdf <- as(s, 'SpatialGridDataFrame')
newr2 <- raster(sgdf, 2)
news <- stack(sgdf)
@


\section{Package design}

The design has emphasised simplicity over speed. All code is written in R, for is clarity, and ease of adapation. However, in some future version we plan to also implement C++ functions to speed up processing of very large datasets. The package is build around a number of S4 classes of which the RasterLayer and RasterStack classes are the most important. Many generic methods are implemented for RasterLayers (arithmic, logical, plot, hist, ...).



\end{document}
