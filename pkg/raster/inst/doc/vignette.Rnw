\documentclass{article}

\usepackage{natbib}
\usepackage{graphics}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage[utf8]{inputenc}

\DeclareMathOperator{\var}{var}
\DeclareMathOperator{\cov}{cov}

% \VignetteIndexEntry{raster package}

\begin{document}

<<foo,include=FALSE,echo=FALSE>>=
options(keep.source = TRUE, width = 60)
foo <- packageDescription("raster")
@

\title{The "raster" package (Version \Sexpr{foo$Version})}
\author{Robert J. Hijmans}
\maketitle


\section{Introduction}

This is a -very brief- vignette for the \verb@raster@ package in R.  The \verb@raster@ package has functions for with spatial raster (grid) data access and manipulation. The package was developed to (1) to provide general low-level raster data manipulation functions (e.g. read raster values by row) that can easily be used to develop higher level specific functions; (2) assure that all these functions can work with very large raster datasets, that are stored on disk as they cannot be loaded into memory; (3) to provide 'high level' functions for raster data manipulation and management that are also commonly available in GIS software; and (4) to provide an easy-to-use raster algebra implementation. 

High level functions include overlay, merge, aggregate, projection, resample, distance, polygon to raster conversion. All these functions work for raster datasets that cannot be loaded into memory. Reading and writing data for most file formats is done via the \verb@rgdal@ package. For 'vector type data (points, lines, polygons), objects of classes defined in the \verb@sp@ package are used. 

With this package, together with other efforts, we would like to help build a bridge to -the powerful statistics and modeling of- R for the "GIS" community. Our perspective is that standard GIS is too map-centric, and that proper data-analysis needs tools that are more model and data centric. 


\section{Some examples}

The first thing to do is to install \verb@raster@ package if you have not yet done so. As the package is currently not on CRAN, this takes a tiny bit more effort than installing packages that are on CRAN. \verb@raster@ depends on \verb@sp@ and \verb@rgdal@ so if you do not have these packages, intsall them first: 
\verb@install.packages(c("rgdal", "sp")@
Now install \verb@raster@ from the R-Forge repository
\verb@install.packages("raster", repos="http://R-Forge.R-project.org")@

The following R statements should now work
<<raster-1>>=
library(raster)
r <- raster()
r[] <- 1:ncell(r)
r[1:10]
plot(r)
@

The command \verb@r <- raster()@ creates a RasterLayer object. RasterLayer objects consist of several parameters describing a raster dataset, such as the number of columns and rows, and the spatial extent. A RasterLayer object does not necessarily contain any raster cell values though. Frequently these values are stored in a file on disk. In this first example we do not have a reference to a file, so we provided some values to the RasterLayer. The values of a RasterLayer are repersented as a (one dimensional) vector, starting in the upper left corner and then increasing to the right and then down row by row untill the last cell in the lower-right corner. An alternative notation for \verb@r[] <- 1:ncell(r)@ is \verb@r <- setValues(r, 1:ncell(r))@.

It is probably more common to create a RasterLayer from a file. The raster package can read raster files support by rgdal and grid data in netCDF format. Here is an example using the Meuse dataset that comes with the sp package:

<<raster-2>>=
r <- raster(system.file("external/test.ag", package="sp"))
r
r <- readRow(r, 50)
values(r)
s <- sqrt(r) - 5
plot(s)
@

The command \verb@r <- raster(filename)@ creates a raster object describing the data on file, but not reading the actual raster cell values. \verb@readRow@ reads the values of a specified row of a raster file into memory. \verb@readAll@ reads all values, but this may not be possible if the file is very large. \verb@values(r)@ returns the values that are currently in memory (i.e. those of row 50). \verb@s <- sqrt(r) - r + 1@ is an example of raster algebra. \verb@s@ is a new RasterLayer, its values are the square root of r minus 5. The computation was done for the entire raster, not just for the values that were in memory. The new values are available in memory and can be inspected via \verb@plot@, @values(r)@, or via indexing, e.g. \verb@r[1:5]@. If the raster file had been very large, the results might have been written to a temporary file.

<<raster-3>>=
r <- raster()
r[] <- 1:ncell(r)
s <- setValues(r, runif(ncell(r)))
ra <- aggregate(r, 10)
r1 <- crop(r, newExtent(-180,0,0,30))
r2 <- crop(r, newExtent(-10,180,-20,10))
m <- merge(r1, r2)
o1 <- overlay(r, s, fun=function(x,y){return(x*y)})
# this is the same as
o2 <- r * s
d <- disaggregate(m, 2)
@


\section{Large files}

The raster package can work with extremely large files because it does not load the files into memory. When a RasterLayer object is created form a file, the object stores some information about the data on disk (number of rows and columns, spatial extent), and it contains a pointer to that file, to read parts of the data as needed. In computations such as raster algebra or the 'higher level functions', data will normally be read in chunks, processed, and written to disk again. If there is no output filename specified (or if that is not possible such as is the case with raster algebra), the results will be written to a temporary file. If you want to keep that file you should move it another location, e.g. using the copyRasterFile or moveRasterFile functions. At the start of each session, the raster package will attempt to delete temporary files it has created in previous sessions.


\section{Package design}

The design has emphasised simplicity over speed. All code is written in R, for is clarity, and ease of adapation. However, in some future version we plan to also implement C++ functions to speed up processing of very large datasets. The package is build around a number of S4 classes of which the RasterLayer and RasterStack classes are the most important. Many generic methods are implemented for RasterLayers (arithmic, logical, plot, hist, ...).



\end{document}
